import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { closeDb, initDB } from '../../src/storage/index.js';
import {
    handleCreateItemTemplate,
    handleGiveItem,
    handleTransferItem,
    handleGetInventory
} from '../../src/server/inventory-tools.js';
import { CharacterRepository } from '../../src/storage/repos/character.repo.js';
import { getDb } from '../../src/storage/index.js';

const mockCtx = { sessionId: 'test-session' };

// Helper to extract JSON from rich formatted responses
function extractJson(text: string): any {
    // Try STATE_JSON format first
    const stateMatch = text.match(/<!-- STATE_JSON\n([\s\S]*?)\nSTATE_JSON -->/);
    if (stateMatch) return JSON.parse(stateMatch[1]);
    
    // Try direct JSON parse
    try {
        return JSON.parse(text);
    } catch {
        // Return empty object if parsing fails
        return {};
    }
}

/**
 * Inventory Exploit Tests
 * Testing for item duplication, quantity exploits, and unique item violations
 */
describe('Inventory Security', () => {
    let charRepo: CharacterRepository;

    beforeEach(() => {
        closeDb();
        initDB(':memory:');
        const db = getDb();
        charRepo = new CharacterRepository(db);

        // Create test characters
        const now = new Date().toISOString();
        charRepo.create({
            id: 'char-a',
            name: 'Character A',
            stats: { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 },
            hp: 20,
            maxHp: 20,
            ac: 10,
            level: 1,
            characterType: 'pc',
            createdAt: now,
            updatedAt: now
        });

        charRepo.create({
            id: 'char-b',
            name: 'Character B',
            stats: { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 },
            hp: 20,
            maxHp: 20,
            ac: 10,
            level: 1,
            characterType: 'pc',
            createdAt: now,
            updatedAt: now
        });
    });

    afterEach(() => {
        closeDb();
    });

    describe('Item Duplication Bug', () => {
        it('should NOT duplicate items when transferring A->B->A', async () => {
            // Create a unique diamond
            const createResult = await handleCreateItemTemplate({
                name: 'Diamond of Infinite Value',
                type: 'misc',
                value: 10000,
                weight: 0.1,
                properties: { unique: true }
            }, mockCtx);
            const item = extractJson(createResult.content[0].text);
            const itemId = item.item?.id || item.id;

            // Give to Character A (quantity 1)
            await handleGiveItem({
                characterId: 'char-a',
                itemId,
                quantity: 1
            }, mockCtx);

            // Verify A has 1
            let invA = await handleGetInventory({ characterId: 'char-a' }, mockCtx);
            let invAData = extractJson(invA.content[0].text);
            const invAItems = invAData.inventory?.items || invAData.items || [];
            expect(invAItems.find((i: any) => i.itemId === itemId)?.quantity).toBe(1);

            // Transfer A -> B
            await handleTransferItem({
                fromCharacterId: 'char-a',
                toCharacterId: 'char-b',
                itemId,
                quantity: 1
            }, mockCtx);

            // Verify A has 0, B has 1
            invA = await handleGetInventory({ characterId: 'char-a' }, mockCtx);
            invAData = extractJson(invA.content[0].text);
            let invB = await handleGetInventory({ characterId: 'char-b' }, mockCtx);
            let invBData = extractJson(invB.content[0].text);

            const invAItems2 = invAData.inventory?.items || invAData.items || [];
            const invBItems = invBData.inventory?.items || invBData.items || [];

            expect(invAItems2.find((i: any) => i.itemId === itemId)).toBeUndefined();
            expect(invBItems.find((i: any) => i.itemId === itemId)?.quantity).toBe(1);

            // Transfer B -> A
            await handleTransferItem({
                fromCharacterId: 'char-b',
                toCharacterId: 'char-a',
                itemId,
                quantity: 1
            }, mockCtx);

            // Verify A has 1, B has 0 (NOT 2 in A!)
            invA = await handleGetInventory({ characterId: 'char-a' }, mockCtx);
            invAData = extractJson(invA.content[0].text);
            invB = await handleGetInventory({ characterId: 'char-b' }, mockCtx);
            invBData = extractJson(invB.content[0].text);

            const invAItems3 = invAData.inventory?.items || invAData.items || [];
            const invBItems2 = invBData.inventory?.items || invBData.items || [];

            const itemInA = invAItems3.find((i: any) => i.itemId === itemId);
            const itemInB = invBItems2.find((i: any) => i.itemId === itemId);

            // THE BUG: This should be 1, not 2
            expect(itemInA?.quantity).toBe(1);
            expect(itemInB).toBeUndefined();

            // Total items in existence should be exactly 1
            const totalQuantity = (itemInA?.quantity || 0) + (itemInB?.quantity || 0);
            expect(totalQuantity).toBe(1);
        });

        it('should NOT allow transferring more items than owned', async () => {
            // Create item and give 5 to A
            const createResult = await handleCreateItemTemplate({
                name: 'Gold Coin',
                type: 'misc',
                value: 1
            }, mockCtx);
            const item = extractJson(createResult.content[0].text);
            const itemId = item.item?.id || item.id;

            await handleGiveItem({
                characterId: 'char-a',
                itemId,
                quantity: 5
            }, mockCtx);

            // Try to transfer 10 (more than owned)
            await expect(
                handleTransferItem({
                    fromCharacterId: 'char-a',
                    toCharacterId: 'char-b',
                    itemId,
                    quantity: 10
                }, mockCtx)
            ).rejects.toThrow();

            // Verify A still has 5
            const invA = await handleGetInventory({ characterId: 'char-a' }, mockCtx);
            const invAData = extractJson(invA.content[0].text);
            const invAItems = invAData.inventory?.items || invAData.items || [];
            expect(invAItems.find((i: any) => i.itemId === itemId)?.quantity).toBe(5);
        });
    });

    describe('Quantity Limits', () => {
        it('should reject absurd quantities', async () => {
            const createResult = await handleCreateItemTemplate({
                name: 'Copper Penny',
                type: 'misc',
                value: 1
            }, mockCtx);
            const item = extractJson(createResult.content[0].text);
            const itemId = item.item?.id || item.id;

            // Try to add 999,999 items (should be rejected)
            await expect(
                handleGiveItem({
                    characterId: 'char-a',
                    itemId,
                    quantity: 999999
                }, mockCtx)
            ).rejects.toThrow(/quantity/i);
        });

        it('should enforce maximum stack size', async () => {
            const createResult = await handleCreateItemTemplate({
                name: 'Arrow',
                type: 'misc',
                value: 1
            }, mockCtx);
            const item = extractJson(createResult.content[0].text);
            const itemId = item.item?.id || item.id;

            // Add items twice - should cap at max
            await handleGiveItem({
                characterId: 'char-a',
                itemId,
                quantity: 100
            }, mockCtx);

            await handleGiveItem({
                characterId: 'char-a',
                itemId,
                quantity: 100
            }, mockCtx);

            const inv = await handleGetInventory({ characterId: 'char-a' }, mockCtx);
            const invData = extractJson(inv.content[0].text);
            const invItems = invData.inventory?.items || invData.items || [];
            const arrows = invItems.find((i: any) => i.itemId === itemId);

            // Max stack should be reasonable (e.g., 9999)
            expect(arrows.quantity).toBeLessThanOrEqual(9999);
        });
    });

    describe('Unique Item Constraints', () => {
        it('should enforce unique item limit of 1 per character', async () => {
            const createResult = await handleCreateItemTemplate({
                name: 'Legendary Sword',
                type: 'weapon',
                value: 50000,
                properties: { unique: true }
            }, mockCtx);
            const item = extractJson(createResult.content[0].text);
            const itemId = item.item?.id || item.id;

            // Give one to A
            await handleGiveItem({
                characterId: 'char-a',
                itemId,
                quantity: 1
            }, mockCtx);

            // Try to give another - should fail with error
            await expect(
                handleGiveItem({
                    characterId: 'char-a',
                    itemId,
                    quantity: 1
                }, mockCtx)
            ).rejects.toThrow(/unique/i);

            // Should still only have 1
            const inv = await handleGetInventory({ characterId: 'char-a' }, mockCtx);
            const invData = extractJson(inv.content[0].text);
            const invItems = invData.inventory?.items || invData.items || [];
            expect(invItems.find((i: any) => i.itemId === itemId)?.quantity).toBe(1);
        });

        it('should NOT allow multiple characters to own same unique item', async () => {
            const createResult = await handleCreateItemTemplate({
                name: 'One Ring',
                type: 'misc',
                value: 999999,
                properties: { unique: true, worldUnique: true }
            }, mockCtx);
            const item = extractJson(createResult.content[0].text);
            const itemId = item.item?.id || item.id;

            // Give to A
            await handleGiveItem({
                characterId: 'char-a',
                itemId,
                quantity: 1
            }, mockCtx);

            // Try to give to B (without transfer) - should fail
            await expect(
                handleGiveItem({
                    characterId: 'char-b',
                    itemId,
                    quantity: 1
                }, mockCtx)
            ).rejects.toThrow(/unique/i);
        });
    });

    describe('Value Limits', () => {
        it('should reject items with absurd values', async () => {
            await expect(
                handleCreateItemTemplate({
                    name: 'Economy Breaker',
                    type: 'misc',
                    value: 999999999999 // Trillion gold
                }, mockCtx)
            ).rejects.toThrow(/value/i);
        });
    });

    describe('Inventory Capacity', () => {
        it('should enforce inventory weight limits', async () => {
            const createResult = await handleCreateItemTemplate({
                name: 'Heavy Boulder',
                type: 'misc',
                value: 1,
                weight: 100
            }, mockCtx);
            const item = extractJson(createResult.content[0].text);
            const itemId = item.item?.id || item.id;

            // Give first boulder (100 weight)
            await handleGiveItem({
                characterId: 'char-a',
                itemId,
                quantity: 1
            }, mockCtx);

            // Try to give second boulder (would be 200 weight, over 100 capacity)
            await expect(
                handleGiveItem({
                    characterId: 'char-a',
                    itemId,
                    quantity: 1
                }, mockCtx)
            ).rejects.toThrow(/capacity|weight/i);
        });
    });
});
